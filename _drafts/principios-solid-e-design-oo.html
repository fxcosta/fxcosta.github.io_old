---
layout: post
title: Princípios SOLID e design OO
date: 
type: post
published: false
status: draft
categories:
- Arquitetura de Software
tags:
- desenvolvimento web
- design oo
- java
- solid
meta:
  _wp_old_slug: principios-solid-design-oo-e-evitando-dores-de-cabeca
  _edit_last: '59574466'
  geo_public: '0'
  _publicize_job_id: '11171075007'
author:
  login: fx3costa0
  email: fx3costa@gmail.com
  display_name: fx3costa
  first_name: ''
  last_name: ''
---
<p>Como primeiro post do meu blog, quero falar um pouco sobre SOLID - que provavelmente você ao menos já ouviu falar em algum lugar -, que nada mais é do que princípios básicos do design orientado a objetos. Mas antes de mais nada, o que de fato é Design Orientado a Objeto? Forçar esses princípios nos fazem pensar melhor em nossos códigos e claro, melhorar o fluxo do nosso software. Uma arquitetura mal planejada é garantia de um projeto com problemas em diversas fases, desde a construção até a manutenção.</p>
<p><!--more--></p>
<p>Quando vamos desenvolver um software orientado a objetos, devemos ter dois objetivos principais em mente enraizados: baixo acoplamento e alta coesão. Pensar de maneira diferente pode ser um tiro no pé.</p>
<p>Já os princípios SOLID que foram abordados inicialmente por Robert Martin, em um artigo chamado <a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod">Principles Of Ood</a>, onde ele elaborou cinco técnicas de programação OO onde cada técnica é uma das letras da palavra SOLID (<strong>Single responsibility, Open-closed, Liskov substitution, Interface segregation e Dependency inversion</strong>). E qual seu principal proposito? Facilitar a manutenção, legibilidade e vida do nosso código. Ah e claro, evitar dores de cabeças futuras.</p>
<p>Vamos ver um pouco sobre cada um desses princípios:</p>
<p><strong>S</strong>RP: <strong>Single Responsibility Principle</strong> (Princípio da Responsabilidade Única)  - Olha a complexidade desse princípio: Uma classe só deve ter uma e somente uma razão para mudar. Ou seja, se observarmos que há mais de uma razão para ela mudar, essa classe deve ser separada em duas. Ela deve ser especializada de tal modo que execute apenas uma tarefa e, de preferência, de uma forma bem feita, evitando aquela classe que faz de tudo um pouco com inúmeras tarefas agregadas a ela. Um exemplo bem simples de classe que viola esse princípio:</p>
<p>[code language="java"]</p>
<p>public class Cliente(){</p>
<p>public void save(Cliente cli){}<br />
public void sendEmail(){}<br />
public void getTotalPrice(){}<br />
}</p>
<p>[/code]</p>
<p>&nbsp;</p>
<p>Uma classe que faz de tudo, persiste, envia e-mail, pega o valor total das compras dele. Isso é um exemplo de muitas responsabilidades em uma única classe. Uma solução para isso - e isso depende das camadas de abstração que o desenvolvedor cria - seria uma classe especifica para persistência, uma classe ou serviço de e-mail e poderiamos ter getTotalPrice() em Cliente.</p>
<p><strong>O</strong>CP: <strong>Open/Closed Principle</strong> (Princípio Aberto / Fechado) - Quando você desenhar as classes do seu sistema você deve prestar atenção para que ela seja abertas para extensão, fechadas para modificação. Ou seja, uma subclasse não pode destruir o conceito da classe pai, por exemplo. Você deve extender, mas não mudar. Se precisar é por que ela esta mal desenhada. Foi exatamente que meu professor de Engenharia descreveu esse princípio.</p>
<p><strong>L</strong>SP: <strong>Liskov Substitution Principle</strong> (Princípio da Substituição de Liskov) - Os tipos derivados devem poder ser substituídos por seus ancestrais. Ou seja se você utilizar um objeto e através de polimorfismo manipulá-lo como sendo do seu tipo base, ele deve funcionar corretamente e deve se comportar da mesma forma como se comportaria se ele realmente fosse daquele tipo. Vamos a um exemplo bem didático que encontrei:</p>
<p>[code language="java"]</p>
<p>class Ave {<br />
public void voar(){}<br />
public void comer(){}<br />
}</p>
<p>class Corvo extends Ave {}</p>
<p>class Avestruz extends Ave{<br />
  voar(){<br />
    throw new UnsupportedOperationException();<br />
  }<br />
}</p>
<p>public TesteDePassaros{<br />
  public static void main(String[] args){<br />
    List&amp;lt;Ave&amp;gt; aveList = new ArrayList&amp;lt;Ave&amp;gt;();<br />
    aveList.add(new Ave());<br />
    aveList.add(new Corvo());<br />
    aveList.add(new Avestruz());<br />
    vamosVoarAves ( aveList );<br />
  }<br />
  static void vamosVoarAves ( List&amp;lt;Ave&amp;gt; aveList ){<br />
    for ( Ave p : aveList ) {<br />
      p.voar();<br />
    }<br />
  }<br />
}<br />
[/code]</p>
<p>O que vai acontecer se rodarmos? Te garanto que o Avestruz não vai voar. Qual seria a melhor implementação nesse caso? Pausa pra meditação ninja... Veja</p>
<p>[code language="java"]</p>
<p>class Ave{<br />
  public void comer(){}<br />
}</p>
<p>class AveVoa extends Ave{<br />
  public void fly()()<br />
}<br />
class AveNaoVoa extends Ave{}</p>
<p>[/code]</p>
<p>Agora faz mais sentido, temos dois tipos de aves.</p>
<p><strong>I</strong>SP: <strong>Interface Segregation Principle</strong> (Princípio de Segregação da Interface) - Muitas interfaces específicas são melhores do que uma interface de uso geral e nossos clientes não devem ser forçados a implementar uma que ele realmente não utilize. E isso é facilmente entendível com um exemplo. Vejamos:</p>
<p>[code language="java"]</p>
<p>public interface Animal {<br />
    void voar();<br />
    void correr();<br />
    void latir();<br />
}<br />
public class Ave implements Animal {<br />
    public void latir() { /* Não faz uso disso */ }<br />
    public void correr() {<br />
        // correndo...<br />
    }<br />
    public void voar() {<br />
        // voando...<br />
    }<br />
}<br />
public class Gato implements Animal {<br />
    public void voar() { throw new Exception(&amp;quot;Ele não voa, parsa&amp;quot;); }<br />
    public void latir() { throw new Exception(&amp;quot;Ele não lati, parsa&amp;quot;); }<br />
    public void correr() {<br />
        // correndo<br />
    }<br />
}<br />
public class Cachorro implements Animal {<br />
    public void voar() { }<br />
    public void latir() {<br />
        // latindo...<br />
    }<br />
    public void correr() {<br />
        // correndo...<br />
    }<br />
}</p>
<p>[/code]</p>
<p>Percebeu que muitos métodos nem fazem sentido existir? Nossos clientes implementaram uma interface mas eles não necessariamente precisam de todos os métodos. Como poderíamos corrigir isso de uma forma mais atraente?</p>
<p>[code language="java"]</p>
<p>public interface Voador {<br />
    void voar();<br />
}<br />
public interface Corredor {<br />
    void correr();<br />
}<br />
public interface Latidor {<br />
    void latir();<br />
}<br />
public class Ave implements Voador, Corredor {<br />
    public void correr() {</p>
<p>    }<br />
    public void voar() {</p>
<p>    }<br />
}<br />
public class Gato implements Corredor{<br />
    public void correr() {</p>
<p>    }<br />
}<br />
public class Cachorro implements Corredor, Latidor {<br />
    public void latir() {  </p>
<p>    }<br />
    public void correr() {</p>
<p>    }<br />
}</p>
<p>[/code]</p>
<p>E agora? muito mais elegante o seu código e de fácil manutenção. Mas ainda falta um último princípio.</p>
<p><strong>D</strong>IP: <strong>Dependency Inversion Principle</strong> (Princípio de Inversão da Dependência) - Partes de mais alto nível não devem depender das partes de menor nível. Ambas devem depender de abstrações; e Abstrações não devem depender de detalhes. Os detalhes é que devem depender de abstrações. Este princípio é muito poderoso, e é a base por trás do conceito de injeção de dependências. É algo um pouco mais complexo até pra explicar, mas observe o exemplo que acredito que você entenderá melhor.</p>
<p>[code language="java"]</p>
<p>class Trabalhador {<br />
	public void trabalhar() {<br />
		// ....&amp;quot;trabaiando&amp;quot;<br />
	}<br />
}</p>
<p>class Gestor {<br />
	Trabalhador trabalhadorUm;</p>
<p>	public void setTrabalhador(Trabalhador t) {<br />
		trabalhadorUm = t;<br />
	}</p>
<p>	public void gerir() {<br />
		trabalhadorUm.trabalhar();<br />
	}<br />
}</p>
<p>class SuperTrabalhador {<br />
	public void trabalhar() {<br />
		//.... trabalhando pra caramba<br />
	}<br />
}</p>
<p>[/code]</p>
<p>Quais desvantagem desse código? Não vou precisar alterar Gestor caso queira que ele também aceite um SuperTrabalhador. Ele não precisa saber exatamente que tipo de trabalhador é, se é um normal ou super, ele precisa receber algum deles e simplesmente colocar pra trabalhar, solucionando essa dependência.</p>
<p>Como isso poderia ser solucionado:</p>
<p>[code language="java"]<br />
interface ITrabalhador {<br />
	public void trabalhar();<br />
}</p>
<p>class Trabalhador implements ITrabalhador{<br />
	public void trabalhar() {</p>
<p>	}<br />
}</p>
<p>class SuperTrabalhador  implements ITrabalhador{<br />
	public void trabalhar() {</p>
<p>	}<br />
}</p>
<p>class Gestor {<br />
	ITrabalhador trabalhadorUm;</p>
<p>	public void setTrabalhador(ITrabalhador t) {<br />
		trabalhadorUm = t;<br />
	}</p>
<p>	public void gerir() {<br />
		trabalhadorUm.trabalhar();<br />
	}<br />
}<br />
[/code]</p>
<p>Ou seja, agora Gestor depende de interfaces abstratas e não de classes concretas, uma vez que implementações concretas são mais propensas a mudanças.</p>
<p>Utilizando os princípios SOLID é possível evitar problemas muito comuns:</p>
<ul>
<li>Dificuldade com unit testings;</li>
<li>Código macarrônico, sem estrutura ou padrão;</li>
<li>Dificuldades de isolar funcionalidades;</li>
<li>Duplicação de código, uma alteração precisa ser feita em N pontos;</li>
<li>Fragilidade, o código quebra facilmente em vários pontos após alguma mudança.</li>
</ul>
<p>Esse foi apenas uma introdução sobre o assunto, até mesmo como guia para estudos próprios futuros. Pretendo falar a respeito de cada um de forma minuciosa com exemplos in-the-real-world.</p>
<p>Qualquer dúvida ou correção, peço-lhe humildemente que entre em contato comigo ou comente abaixo. Será de grande ajuda para manter o debate sobre esse assunto tão importante que é o design de software.</p>
<p><strong>Referências</strong>:</p>
<ul>
<li><a href="http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod" target="_blank">Clean Code – Uncle Bob</a></li>
<li><a href="http://www.objectmentor.com/resources/articles/Principles_and_Patterns.pdf" target="_blank">Design Principles and Design Patterns</a> (PDF)</li>
<li><a href="http://eduardopires.net.br/2013/04/orientacao-a-objeto-solid/">Orientação a Objetos - SOLID</a></li>
<li><a href="http://www.oodesign.com/">OODesign.com</a></li>
<li><a href="http://blog.gauffin.org/2012/05/solid-principles-with-real-world-examples/">SOLID Principles with real world examples</a></li>
</ul>
